# Python

</br>

#### 多线程与GIL

- Python虚拟机使用一个**全局解释器锁**（Global Interpreter Lock）来互斥线程对Python虚拟机的使用。为了支持多线程机制，一个基本的要求就是需要实现不同线程对共享资源访问的互斥，所以引入了`GIL`。
- 在一个线程拥有了解释器的访问权之后，其他的所有线程都必须等待它释放解释器的访问权，即使这些线程的下一条指令并不会互相影响。
- 不管进程中有多少线程，**只有拿到了GIL锁的线程才可以在CPU上运行**，即使是多核处理器。对一个进程而言，不管有多少线程，任一时刻，只会有一个线程在执行。

> [!NOTE|label:GIL]
> **缺点**：多处理器退化为单处理器。</br>
> **优点**：避免大量的加锁解锁操作。

</br>

#### 什么情况下适合使用多线程

- 对于**CPU密集型的线程**（各种循环处理、计数等等），多线程效率比较低，多进程效率高。
- 对于**IO密集型代码**（文件处理、网络爬虫等），多线程能够有效提升效率（单线程下有IO操作会进行IO等待，造成不必要的时间浪费，而开启多线程能在线程A等待时，自动切换到线程B，可以不浪费CPU的资源，从而能提升程序执行效率）。

</br>

#### 生成器

- 直接创建一个包含大量元素的列表需要占用很大的存储空间。如果列表元素可以按照某种算法推算出来，那就可以在循环的过程中不断推算出后续的元素，这样就不必创建完整的列表，从而节省大量的空间。在Python中，**这种一边循环一边计算的机制，称为生成器**（Generator）。
- 生成器是一个特殊的程序，可以被用作控制循环的迭代行为，Python中**生成器是迭代器的一种，使用`yield`返回值函数**，每次调用`yield`会暂停，而可以使用`next()`函数和`send()`函数恢复生成器。生成器一次只能产生一个值，这样消耗的内存数量将大大减小。

> [!TIP|label:创建生成器的方式]
1. 生成器表达式</br>
  用括号而不是中括号创建的嵌套循环是生成器，如`generator_ex = (x*x for x in range(10))`，可以通过多次`next(generator_ex)`操作进行访问，但这样在遍历结束的时候再次调用`next()`会抛出异常。**更常规的方式是使用for循环**`for i in generator_ex`。
2. 生成器函数</br>
  使用`yield`函数，在一个函数中的某一循环内，使用`yield`函数返回单次循环的某个计算结果（而不是全部计算完放在一个列表中`return`）。调用函数时也需要**使用for循环**，`yield`执行后函数会挂起，直到下一轮循环。

</br>

#### 迭代器

- 可以被`next()`函数调用并不断返回下一个值的对象称为**迭代器**（Iterator）。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束，迭代器**只能往前不会后退**，它在正确的范围内返回期待的数据，在超出范围后能够抛出`StopIteration`的错误并停止迭代。
- 可以把迭代器这个数据流看做是一个有序序列，但却不能提前知道序列的长度，只能不断通过`next()`函数实现按需计算下一个数据，所以迭代器的计算是惰性的，**只有在需要返回下一个数据时它才会计算**。因此，**常见的可迭代对象**列表、字典、字符串**都不是迭代器**。

> [!TIP|label:创建迭代器的方式]
> 1. 把可迭代对象变成迭代器</br>
  采用`iter()`函数包裹可迭代对象，使它们变成迭代器。迭代器甚至可以表示一个无限大的数据流，例如全体自然数，而使用列表是永远不可能存储全体自然数的。
> 2. 构造生成器</br>
  生成器本身就是一种迭代器，但是只可以读取它一次，因为用的时候才生成。
> 3. 把类构造为迭代器</br>
  通过实现类的方法`__iter__()`使得类返回一个迭代器，再实现方法`__next__()`使得可以返回下一个迭代器对象。

</br>

#### 生成器和迭代器的区别

- **生成器是一个只能遍历一遍的特殊迭代器。**
- 生成器可以只使用`yield`关键字，而无需创建`iter()`和`next()`方法，显得特别简洁。

</br>

#### 什么是闭包

- 如果在一个函数的内部定义了另一个函数，外部的函数叫它**外函数**，内部的函数叫它**内函数**。
- 闭包的条件
  1. 在一个外函数中定义了一个内函数；
  2. 内函数里运用了外函数的临时变量；
  3. 并且外函数的返回值是内函数的引用。
- 一般情况下，如果一个函数结束，函数的内部临时变量都会释放掉，还给内存。但是闭包是一种特殊情况，如果外函数在结束的时候发现有自己的临时变量将来会在内部函数中用到，就**把这个临时变量绑定给了内部函数**，然后自己再结束。
- 在闭包中如果需要修改闭包变量（外函数绑定给内函数的局部变量），可以用`nonlocal`声明。

</br>

#### 装饰器

- 装饰器（Decorators）就是用于拓展原来函数功能的一种函数，**目的是在不改变原函数名或内容的情况下，给函数增加新的功能**。装饰器可以让其他函数在不需要做任何代码变动的前提下**增加额外功能**，装饰器的返回值也是一个函数对象。通常抽离出来的功能是与函数功能本身无关的雷同代码并需要重用。
- 装饰器是建立在闭包的前提上的，因此装饰器满足闭包的条件。

> [!TIP|label:创建装饰器的方式]
> 1. 通过函数嵌套创建的装饰器</br>
>   ```python
>   from functools import wraps
>   def decorator_name(f):
>       @wraps(f)
>       def decorated(*args, **kwargs):
>           return f(*args, **kwargs)
>       return decorated
>   @decorator_name
>   def func():
>       return 1
>   ```
> 2. 把类构造为装饰器</br>
>   ```python
>   class decorator_name(object):
>       def __init__(self, f):
>           self.f = f
>       def __call__(self, *args, **kwargs):
>           self.f()
>   @decorator_name
>   def func():
>       return 1
>   ```

</br>

#### 多个装饰器的执行顺序

- **在函数定义阶段：**执行顺序是从最靠近函数的装饰器开始，**自内而外**的执行。
- **在函数执行阶段：**执行顺序**由外而内**，一层层执行。

</br>

#### 什么是反射

- 反射可以把**字符串映射到**实例的**变量**或者实例的**方法**然后可以去执行调用、修改等操作。
- 反射的四个重要的方法：
  1. `hasattr`：判断对象中是否有这个变量或方法；
  2. `getattr`：获取指定字符串名称的变量或方法的引用；
  3. `setattr`：为对象添加变量或方法；
  4. `delattr`：删除对象中的变量，但不能删除方法。

> [!WARNING]
> `attr`是属性英文的前几个字母，属性指的是类中类变量、实例变量和方法。但是要注意不能是私有的，如果变量是以`_`开头，那将无法获取。

</br>

#### `cls`和`self`

- 在类的普通实例方法中，第一个参数需要是`self`，它代表**一个具体的类的实例**。
- 在通过`@classmethod`装饰的类方法中，第一个参数是`cls`，它表示这个**类本身**。

</br>

#### `@property`、`@classmethod`和`@staticmethod`

- Python类中的普通方法可以称作**实例方法**，而通过`@property`装饰的方法被**伪装成一个属性**，通过`@classmethod`装饰的方法称作**类方法**，通过`@staticmethod`装饰的方法称作**静态方法**。
- `@property`装饰的方法在调用的时候**被视作是一个属性**，可以直接访问，但不能再当作函数的形式调用（即不能加括号和参数）。
- `@classmethod`装饰的**类方法第一个参数是`cls`**，在方法内部可以对类本身进行参数初始化、调用类的方法、实例化对象等，可以返回`cls`或其它值。

> [!NOTE]
> 如果返回`cls`，则可以通过接收`cls`得到一个新的类，再进行实例化。

- `@staticmethod`装饰的**静态方法不可以持有参数`self`或`cls`**，也不可以调用类的其它属性或方法。它和一个常规的全局函数作用相同，但出于某种需求封装在类的内部。
- 类方法和静态方法都可以通过**类对象**或**类对象的某个实例**访问。

</br>

#### `*args`与`**kwargs`

- **当函数的参数不确定或数量不确定时**，可以使用`*args`与`**kwargs`来打包参数。
- `*args`用来将连续的未指定对应参数名的参数打包成**`tuple`**给函数体调用。
- `**kwargs`用来将连续的关键字参数打包成**`dict`**给函数体调用。

> [!WARNING|label:参数顺序]
> 参数`arg`、`*args`、`**kwargs`三个参数的位置是一定的，必须是`(arg, *args, **kwargs)`这个顺序，否则程序会报错。

</br>

#### 可变对象与不可变对象

- 在Python中，对对象有一种很通俗的说法，万物皆对象。说的就是构造的任何数据类型都是一个对象，无论是数字、字符串、还是函数，甚至是模块，Python都当做对象处理。
- 按更新对象的方式，可以将对象分为两大类：**可变对象**与**不可变对象**。
- 可变对象：列表`list`、字典`dict`、集合`set`。</br>
  所谓可变是指可变对象的值可变，身份（id）是不变的。
- 不可变对象：数字`int/float`、字符串`str`、元组`tuple`。</br>
  不可变对象就是对象的身份和值都不可变。新创建的对象被关联到原来的变量名，旧对象被丢弃，垃圾回收器会在适当的时机回收这些对象。

> [!TIP|label:元组是不可变的吗]
> - 元组是一个不可变对象，元组与列表最重要的区别就在于元组一经定义就不能改变其内容。
> - 但是由于元组中存放的是对象的引用，**如果对象是一个可变对象，那该位置的对象是可变的**。

</br>

#### 对象与引用

在Python中，每个对象都会在内存中申请开辟一块空间来保存该对象，**该对象在内存中所在位置的地址被称为引用**。在开发程序时，**变量就是地址的一种表示形式**，并不开辟开辟存储空间。

</br>

#### 深拷贝和浅拷贝

在Python中，**对象赋值实际上是对象的引用**。当创建一个对象，然后把它赋给另一个变量的时候，Python并没有拷贝这个对象，而只是拷贝了这个对象的引用。
1. 直接赋值的时候，**默认只传递当前对象的引用**。如原始列表`a`改变，被赋值的`b`也会做相同的改变。
2. `copy`浅拷贝，拷贝当前对象，**但没有拷贝当前对象内部的子对象**，所以当子对象的原始数据改变，拷贝后容器内的子对象也会改变。常见的在嵌套列表中，尽管对外层列表`a`的改变不会造成拷贝后的`b`的变化，但对`a`的内部子列表的改变会影响`b`。
3. `deepcopy`深拷贝，**包含当前对象内部子对象的拷贝**，并且是递归地拷贝每一个子对象中可能的次子对象。因此，无论存在多少层的嵌套列表（或对象），对原始对象`a`的改变都不会影响拷贝后的`b`。

</br>

#### 列表的切片操作

- 列表的切片更像是一个**浅拷贝**行为，如`b = a[:]`或`b = a[1: 5]`或`b = a[::-1]`，对当前列表内的元素进行了拷贝，但没有拷贝任何子对象。对`b`中**不可变子对象的修改**，或**对某个位置的直接替换**，或**添加元素**不会对原始列表`a`产生影响，但对可变子对象内部的修改会产生影响。
- 对嵌套列表的切片也遵循上述规则，但更为复杂。若令`a = [[1, 2, 3], [4, 5, 6]]`
  1. `b = a[:][0]`，由于先对`a`进行了浅拷贝，但`a`内元素都是可变对象，因此随后对`b`的任何操作都**会影响`a`**；
  2. `b = a[0][:]`，由于先取`a[0]`后再进行浅拷贝，且`a[0]`内元素都是不可变对象，因此随后对`b`的任何操作都**不会影响`a`**。
  3. `b = a[:][:]`，仅等同与两次浅拷贝，与一次浅拷贝无异。
  4. 任何多层容器嵌套都可以参考以上规则。
- 如果使用NumPy将嵌套列表处理为矩阵，对切片后的**值修改**，都会影响原始矩阵。

</br>

#### 匿名函数

- 匿名函数通过`lambda`关键字来创建，也意味着这是一个没有名字的函数。
- 语法规则为：`lambda 参数列表: 表达式`。
- **冒号后面的表达式有且只能有一个**，且自动`return`表达式的计算后的结果。
- 普通函数往往用来去处理一些比较复杂的程序逻辑，而匿名函数则仅仅是处理功能非常简单的逻辑。

> [!TIP|label:匿名函数的使用]
> 1. 通过变量接收匿名函数，再调用变量
> ```python
> add = lambda x, y: x + y
> print(add(3, 5))
> ```
> 2. 组合调用
> ```python
> filter(lambda x: x % 3 == 0, [1, 2, 3, 4, 5, 6])
> ```

</br>

#### `_`、`__`和`__xx__`

- 在Python的类中，不管是方法还是属性都没有真正的私有化。为了编程的需要，约定加了下划线`_`开头的属性和方法不属于API，**不应该在类的外面访问**（尽管可以访问），也不会被`from M import *`导入。
- 双下划线`__`开头的作用是**避免子类覆盖其内容**。它主要和**命名修饰**有关，类`A`中定义的`__method()`方法实际上会变名为`_A__method()`。其子类`B`无法彻底重写该方法，因为在`B`中重写的方法会被命名为`_B__method()`。在类外调用`__method()`方法是不合法的，但这不代表该方法是私有的，因为**可以调用`_A__method()`方法**。

> [!NOTE]
> 如果重写的方法强行命名为`_A__method()`，可以影响调用，但依然不算重写成功。

- `__xx__`通常指的是一些对象的**特殊属性或方法**，包括类的初始化、重写操作符等。这些方法通常是Python内置的，需要赋值或重写，但通常不进行自定义。

</br>

#### 常见的特殊属性和方法

- 属性
  1. `__doc__`：帮助说明，将字符串写在对象定义声明之下；
  2. `__module__`：模块名，就是文件的名字（无后缀）部分；
  3. `__class__`：返回对象的类信息；
  4. `__dict__`：存储对象属性/方法的字典。
- 方法（类的专有方法）
  1. `__init__`：构造函数，在生成对象时调用；
  2. `__del__`：析构函数，释放对象时使用；
  3. `__setitem__`：按照索引赋值（相当于列表索引）；
  4. `__getitem__`：按照索引获取值；
  5. `__len__`：获得长度；
  6. `__cmp__`：比较运算；
  7. `__call__`：函数调用；
  8. `__add__`：加运算。

</br>

#### `__init__`和`__new__`有什么区别

- 二者均是Python面向对象语言中的函数，`__new__`比较少用，`__init__`则用的比较多。
- `__new__`是**在实例创建之前被调用的**，因为它的任务就是创建实例然后返回该实例对象，是个静态方法。
- `__init__`是**当实例对象创建完成后被调用的**，然后设置对象属性的一些初始值，通常用在初始化一个类实例的时候，是一个实例方法。

> [!TIP|label:构造器]
> - 类中的`__init__`方法又被称为构造器，为实例提供初始化的属性。
> - 如果类中没有定义`__init__`方法，实例创建之初仅是一个简单的名称空间。

</br>

#### 单例模式

- 单例模式，也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，**单个类对象必须保证只有一个实例存在**。
- 实现单例模式的方法
  1. 重写`__new__()`方法，使得第一个实例化对象绑定参数`__instance`（非固定名称），若`__instance`存在，则类无法继续实例化新的对象；
  2. 将实例化后的对象作为模块导入；
  3. 使用装饰器设计单例模式的装饰函数，方便使更多的类变为单例模式。

</br>

#### 工厂模式

- 工厂模式是一个在软件开发中用来创建对象的设计模式。
- 定义一个用来实例化对象的函数，但是其本身不进行实例化，通过参数由**子类来决定需要实例化的类是哪一个**。

> [!NOTE|label:工厂模式的优点]
> 1. 松耦合，**对象的创建独立于类的实现**；
> 2. **客户端无需了解创建对象的类**，只需知道需要传递的接口、方法和参数就能够创建所需要的对象；
> 3. **很容易扩展工厂添加其他类型对象的创建**，而使用者只需要改变参数就可以了。

</br>

> [!NOTE|label:参考资料]
> [python生成器和迭代器有这篇就够了](https://www.cnblogs.com/wj-1314/p/8490822.html)</br>
> [多个装饰器的执行顺序](https://blog.csdn.net/u013411246/article/details/80571462)</br>
> [Python对象的赋值和拷贝](https://blog.csdn.net/liuweiyuxiang/article/details/89350481)</br>
> [python设计模式之工厂模式](https://www.cnblogs.com/sfencs-hcy/p/10029960.html)
