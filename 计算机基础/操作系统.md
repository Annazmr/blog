# 操作系统

</br>

#### 线程与进程有什么区别

  > [!TIP|label:概念]
  > 进程是操作系统**资源分配**的最小单位，线程是**任务调度和执行**（CPU调度）的最小单元。

- 线程与进程的执行是有区别的。</br>
  每个独立的线程有自己的程序入口、顺序执行序列和程序的出口，但是线程不能独立执行，必须依附于程序之中，由应用程序提供多个线程的并发控制。
- 通常在一个进程中可以包含若干个线程，当然**一个进程中至少有一个线程**，不然没有存在的意义。
- **进程有自己独立的地址空间**，每启动一个进程，系统都会为其分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵；</br>
  **线程没有独立的地址空间**，它使用相同的地址空间**共享数据**，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。
- 多线程程序只要有一个线程死掉，整个进程也死掉了；</br>
  **多进程程序更健壮**，在保护模式下，一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。
- **线程之间通信更方便**，同一个进程下，线程共享全局变量、静态变量等数据（但多线程程序处理好同步与互斥是个难点）；</br>
  而进程之间的通信需要以**通信**的方式（IPC）进行。

</br>

#### 进程间通信与线程间通信

- 不同进程间有着不同的虚拟地址空间，所以**进程间的通信不能简单的直接共享内存**，常用的通信方式有管道、共享内存、消息队列、信号量、套接字等。
- 线程是**共享进程的内存空间**，所以考虑好互斥和同步即可，常用的通信方式有：锁（互斥）、条件变量（同步）、信号量（同步）。

</br>

#### 进程的三个状态

- **就绪状态**其实就是获取了除CPU外的所有资源，只要处理器分配资源就可以马上执行。就绪状态有相关的排队序列。
- **运行状态**就是获得了处理器分配的资源，程序开始执行。
- **阻塞状态**，当程序条件不够时候，需要等待条件满足时候才能执行，如等待IO操作时候，此刻的状态就叫阻塞态。

</br>

#### 什么是协程

- 协程是一个线程情况下，多个执行流程（即协程）由线程控制，分别使用分配给该线程的机器资源的概念。协程可以理解为线程内部调度的基本单位。
- 处理器调度（即线程）会有很大的场景切换消耗，而对处理器来说，协程属于同一个调度，切换消耗较小。
- 在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。

</br>

#### 什么是死锁

在两个或者多个并发进程中，如果**每个进程持有某种资源**而又**等待其它进程释放它们所持有的资源**，造成在未改变这种状态之前**都不能向前推进**，称这一组进程产生了死锁。通俗的讲，就是两个或多个进程无限期的阻塞、相互等待的一种状态。

</br>

#### 死锁产生的四个必要条件

- **互斥：**至少有一个资源必须属于非共享模式，即一次只能被一个进程使用；若其他申请使用该资源，那么申请进程必须等到该资源被释放为止。
- **占有并等待：**一个进程必须占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有。
- **非抢占：**进程不能被抢占，即资源只能被进程在完成任务后自愿释放。
- **环路等待：**若干进程之间形成一种头尾相接的环形等待资源关系。

</br>

#### 处理死锁的基本策略

- **死锁预防：**基本思想是只要确保死锁发生的**四个必要条件中至少有一个不成立**，就能预防死锁的发生，具体方法包括：
  1. 打破互斥条件：允许进程同时访问某些资源。受限于资源本身属性，这种办法通常并无实用价值。
  2. 打破占有并等待条件：可以实行资源预先分配策略，或者只允许进程在没有占用资源时才可以申请资源。
  3. 打破非抢占条件：允许进程强行从占有者哪里夺取某些资源，实现起来困难，会降低系统性能。
  4. 打破循环等待条件：实行资源有序分配策略。对所有资源排序编号，所有进程对资源的请求必须严格按资源序号递增的顺序提出。
- **死锁避免：**基本思想是**动态地检测资源分配状态，以确保循环等待条件不成立**，从而确保系统处于安全状态。所谓安全状态是指：如果系统能按某个顺序为每个进程分配资源（不超过其最大值），那么系统状态是安全的。**资源分配图算法**和**银行家算法**是两种经典的死锁避免的算法。
- **死锁解除：**常用的两种方法为**进程终止和资源抢占**。所谓进程终止是指简单地终止一个或多个进程以打破循环等待，所谓资源抢占是指从一个或多个死锁进程那里抢占一个或多个资源。

> [!TIP|label:银行家算法]
> 银行家算法是从当前状态出发，按照系统各类资源剩余量逐个检查各进程需要申请的资源量，找到一个各类资源申请量均小于等于系统剩余资源量的进程P1。然后分配给该P1进程所请求的资源，假定P1完成工作后归还其占有的所有资源，更新系统剩余资源状态并且移除进程列表中的P1，进而检查下一个能完成工作的客户。**如果所有客户都能完成工作，则找到一个安全序列，银行家才是安全的。若找不到这样的安全序列，则当前状态不安全。**

</br>

#### 堆和栈

- **栈由操作系统自动分配释放**，用于存放函数的参数值、局部变量等，其操作方式类似于数据结构中的栈。</br>
  在函数中定义的局部变量按照先后定义的顺序依次压入栈中，也就是说相邻变量的地址之间不会存在其它变量。**栈的内存地址生长方向由高到底**，所以后定义的变量地址低于先定义的变量。栈中存储的数据的生命周期随着函数的执行完成而结束。
- **堆由程序员分配释放**，若程序员不释放，程序结束时由OS回收。</br>
  **堆的内存地址生长方向与栈相反，由低到高**，但需要注意的是，后申请的内存空间并不一定在先申请的内存空间的后面，原因是先申请的内存空间一旦被释放，后申请的内存空间则会利用先前被释放的内存。堆中存储的数据的若未被释放，则其生命周期等同于程序的生命周期。

</br>

#### 堆和栈的区别

堆与栈实际上是操作系统对进程占用的内存空间的两种管理方式，主要有如下几种区别：
1. **管理方式不同。**栈由操作系统自动分配释放，无需手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏。
2. **空间大小不同。**每个进程拥有的栈的大小要远远小于堆的大小。
3. **生长方向不同。**堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低。
4. **分配方式不同。**堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。
5. **分配效率不同。**栈由操作系统自动分配，会在硬件层级对栈提供支持，这就决定了栈的效率比较高；堆则是由C/C++提供的库函数或运算符来完成申请与管理。
6. **存放内容不同。**栈存放的内容，函数返回地址、相关参数、局部变量和寄存器内容等；堆一般情况堆顶使用一个字节的空间来存放堆的大小，而堆中具体存放内容是由程序员来填充的。

> [!TIP|label:堆和栈在编程语言中的体现]
> - 在C/C++中，常规声明的变量存储在栈中；使用`malloc`或`new`申请的变量存储在堆中，可以通过`free`或`delete`释放。
> - 在Python中，**变量位于栈，对象位于堆**，变量实际上就是对象的引用。

</br>

> [!NOTE|label:参考资料]
> [面试之进程和线程](https://blog.csdn.net/wolf_break/article/details/84769653)</br>
> [面试/笔试第二弹 —— 操作系统面试问题集锦](https://blog.csdn.net/justloveyou_/article/details/78304294)</br>
> [银行家算法](https://www.jianshu.com/p/5d01e5db5eaf?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation)</br>
> [堆与栈的区别](https://blog.csdn.net/K346K346/article/details/80849966)
>